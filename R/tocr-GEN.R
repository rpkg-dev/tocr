# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/tocr.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literature programming approach used applying the R Markdown format.

utils::globalVariables(names = c("."))

#' Get non-code-block indices
#' 
#' @keywords internal
get_non_code_block_indices <- function(md_lines) {
  
  non_code_block_indices <- integer()
  
  if (length(md_lines) > 0L) {
    
    is_inside_code_block <- FALSE
    is_tilde <- FALSE
    nr_of_fence_chars <- 3L
    
    for (i in seq_along(md_lines)) {
      
      if (is_inside_code_block) {
        
        # code block ends?
        if (stringr::str_detect(string = md_lines[[i]],
                                pattern = paste0("^ {0,3}",
                                                 dplyr::if_else(is_tilde, "~", "`"),
                                                 "{", nr_of_fence_chars, ",} *$"))) {
          is_inside_code_block %<>% not()
        }
        
      } else {
        
        # code block starts?
        if (stringr::str_detect(string = md_lines[i],
                                pattern = "^ {0,3}(`{3,}([^`]*)?|~{3,}([^~]*)?)$")) {
          
          is_tilde <- stringr::str_detect(string = md_lines[i],
                                          pattern = "^ {0,3}~{3,}")
          
          nr_of_fence_chars <- stringr::str_count(string = md_lines[i],
                                                  pattern = dplyr::if_else(is_tilde, "~", "`"))
        } else {
          
          non_code_block_indices %<>% c(i)
        }
      }
    }
  }
  non_code_block_indices
}

#' Handle existing TOC (integrity checks and removal)
#' 
#' @keywords internal
handle_existing_toc <- function(md_lines,
                                non_code_block_indices,
                                position,
                                filename) {
  
  # get begin and end line numbers of possibly existing old TOC
  toc_begin_position <-
    stringr::str_which(
      string = md_lines,
      pattern = "(?i)^\\s*<!--\\s*((START\\s+doctoc(\\s.*)?|TOC\\s+((BEGIN|START|depth|withlinks|updateOnSave|orderedList).*)?)|ts)\\s*-->"
    ) %>%
    magrittr::extract(. %in% non_code_block_indices)
  
  toc_end_position <-
    stringr::str_which(
      string = md_lines,
      pattern = "(?i)^\\s*<!--\\s*((END\\s+doctoc|TOC\\s+END)(\\s.*)?|(te|/TOC))\\s*-->"
    ) %>%
    magrittr::extract(. %in% non_code_block_indices)
  
  # check if an old TOC already exists
  toc_exists <- length(toc_begin_position) > 0L | length(toc_end_position) > 0L
  
  if (toc_exists) {
    
    # wrap filename in apostrophes
    if (filename != "Input") filename %<>% paste0("'", ., "'")
    
    # TOC integrity checks
    if (length(toc_begin_position) != length(toc_end_position)) {
      
      rlang::abort(paste0(
        "\n", filename, " corrupted. It contains unmatched 'TOC BEGIN/END' comments. Nothing done.\n",
        "See line numbers ", paste0(sort(unique(toc_begin_position, toc_end_position)), collapse = ", "), ".\n"
      ))
      
    } else if (length(toc_begin_position) > 1L) {
      
      rlang::abort(paste0(
        "\n", filename, " corrupted. It contains multiple 'TOC BEGIN/END' comment pairs (normal would be 0 or 1). Nothing done.\n",
        "See line numbers ", paste0(sort(unique(toc_begin_position, toc_end_position)), collapse = ", "), ".\n"
      ))
      
    }
    if (toc_begin_position > toc_end_position) {
      
      rlang::abort(paste0(
        "\n", filename, " corrupted. Existing 'TOC BEGIN' comment comes after existing 'TOC END' comment. Nothing done.\n",
        "See line numbers ", paste0(sort(unique(toc_begin_position, toc_end_position)), collapse = ", "), ".\n"
      ))
    }
    
    # also include surplus empty lines (in order to get rid of them)
    ## before TOC
    while (stringr::str_detect(string = md_lines[max(toc_begin_position - 1L, 1L)],
                               pattern = "^\\s*$")
           & toc_begin_position > 1L) {
      toc_begin_position %<>% magrittr::subtract(1L)
    }
    ## after TOC
    while (stringr::str_detect(string = md_lines[min(toc_end_position + 1L, length(md_lines))],
                               pattern = "^\\s*$")
           & toc_end_position < length(md_lines)) {
      toc_end_position %<>% magrittr::add(1L)
    }
    
    # calculate position offset
    if (is.numeric(position) & position > toc_begin_position) {
      position_offset <- toc_end_position - toc_begin_position
      
    } else {
      position_offset <- 0L
    }
    
    # remove old TOC
    ## if TOC is topmost
    if (toc_begin_position == 1L) {
      
      md_lines <- md_lines[(toc_end_position + 1L) : length(md_lines)]
      
      ## if TOC is undermost (ensure there's an empty line at the end)
    } else if (toc_end_position == length(md_lines)) {
      
      md_lines <- c(md_lines[1L : (toc_begin_position - 1L)], "")
      
      ## if TOC is somewhere in the middle
    } else {
      
      md_lines <- c(md_lines[1L : (toc_begin_position - 1L)],
                    "",
                    md_lines[(toc_end_position + 1L) : length(md_lines)])
    }
  } else {
    
    position_offset <- 0L
  }
  
  # adapt non-code-block indices
  if (toc_exists) {
    
    ## remove TOC indices
    non_code_block_indices %<>% setdiff(y = toc_begin_position:toc_end_position)
    ## consider position offset
    non_code_block_indices[non_code_block_indices > toc_end_position] %<>% magrittr::subtract(toc_end_position - toc_begin_position)
  }
  
  list(md_lines = md_lines,
       position_offset = position_offset,
       non_code_block_indices = non_code_block_indices)
}

#' Evaluate `position`
#' 
#' @keywords internal
evaluate_position <- function(position,
                              position_offset,
                              md_lines,
                              min_tier,
                              filename) {
  
  # handle numeric position values
  if (is.numeric(position)) {
    
    # adjust position value to TOC-free `md_lines`
    position %<>% magrittr::subtract(position_offset)
    
    # check if numeric position value exceeds the maximum number of lines
    if (position > length(md_lines) + 1L) {
      
      rlang::warn("\nProvided `position` argument of ", position + position_offset, " is greater than the number of lines of '", filename,
                  "'!\n`position` has therefore been set to \"bottom\".\n")
      
      position <- length(md_lines) + 1L
    }
    
    # handle semantic position values
  } else if (position == "top") {
    
    position <- 1L
    
  } else if (position == "bottom") {
    
    position <- length(md_lines) + 1L
    
  } else if (position == "above") {
    
    position <- dplyr::if_else(min_tier == 1L,
                               1L,
                               stringr::str_which(string = md_lines,
                                                  pattern = paste0("^ {0,3}#{", min_tier, ",6}\\s+\\S")) %>%
                                 dplyr::first() %>%
                                 ifelse(is.na(.), 2L, .) %>%
                                 magrittr::subtract(1L) %>%
                                 seq(from = 1L) %>%
                                 magrittr::extract(md_lines, .) %>%
                                 stringr::str_which(pattern = paste0("^ {0,3}#{1,", min_tier, "}\\s+\\S")) %>%
                                 dplyr::last() %>%
                                 ifelse(is.na(.), 0L, .) %>%
                                 magrittr::add(1L))
    
  } else if (position == "below") {
    
    position <-
      stringr::str_which(string = md_lines,
                         pattern = paste0("^ {0,3}#{", min_tier, ",6}\\s+\\S")) %>%
      dplyr::first() %>%
      ifelse(is.na(.), 1L, .)
    
  } else if (position == "below") {
    
    position <- -1L
    
  } else rlang::abort("This shouldn't be possible!")
  
  position
}

#' Convert header text to HTML anchor
#' 
#' @keywords internal
convert_header_to_anchor <- function(header_text,
                                     md_flavor,
                                     preceding_anchor_links = character(),
                                     backlink_string = character(),
                                     backlink_position) {
  # return NA unprocessed
  if (!is.na(header_text)) {
    
    # add backlink dummy if necessary
    if (length(backlink_string) & isTRUE(!is.na(backlink_string))) {
      
      if (backlink_position == "after") {
        
        header_text %<>% paste0(., " [", backlink_string, "](dummylink)")
        
      } else {
        
        header_text %<>% paste0("[", backlink_string, "](dummylink) ", .)
      }
    }
    
    # convert ASCII chars to lower case
    ## get non-ASCII char indices
    non_ascii_char_indices <-
      header_text %>%
      stringr::str_locate_all(pattern = "[^[:ascii:]]") %>%
      dplyr::first() %>%
      .[, 1L]
    
    ## split header into single chars
    header_split <-
      header_text %>%
      stringr::str_split(pattern = "") %>%
      dplyr::first()
    
    ## only convert ASCII chars to lower case
    if (length(non_ascii_char_indices)) {
      
      header_split[-non_ascii_char_indices] %<>% stringr::str_to_lower()
      
    } else {
      
      header_split %<>% stringr::str_to_lower()
    }
    
    ## put single chars back together
    anchor_link <- header_split %>% paste0(collapse = "")
    
    # clean
    anchor_link %<>%
      ## remove HTML tags
      stringr::str_replace_all(pattern = "</?[:alnum:]+?>",
                               replacement = "") %>%
      ## replace markdown links with link text
      stringr::str_replace_all(pattern = "\\[([^\\]]*?)\\]\\([^\\)]*?\\)",
                               replacement = "\\1") %>%
      ## remove unallowed characters
      stringr::str_replace_all(pattern = "[^[:alnum:]\\s_-]",
                               replacement = "") %>%
      ## remove first three enclosing `_` (GitLab quirk)
      stringr::str_replace_all(pattern = "\\b_(\\w*?[^_]+?\\w*?)_\\b",
                               replacement = "\\1") %>%
      stringr::str_replace_all(pattern = "\\b_(\\w*?[^_]+?\\w*?)_\\b",
                               replacement = "\\1") %>%
      stringr::str_replace_all(pattern = "\\b_(\\w*?[^_]+?\\w*?)_\\b",
                               replacement = "\\1")
    
    ## remove remaining enclosing `_` if md_flavor is not GitLab
    if (md_flavor != "gitlab") {
      
      while (stringr::str_detect(string = anchor_link,
                                 pattern = "\\b_(\\w*?[^_]+?\\w*?)_\\b")) {
        anchor_link %<>%
          stringr::str_replace_all(pattern = "\\b_(\\w*?[^_]+?\\w*?)_\\b",
                                   replacement = "\\1")
      }
    }
    
    anchor_link %<>%
      # replace whitespaces with hyphens
      stringr::str_replace_all(pattern = "\\s",
                               replacement = "-") %>%
      # escape non-ASCII chars
      curl::curl_escape()
    
    # markdown flavor specific quirks
    ## GitLab
    if (md_flavor == "gitlab") {
      
      # replace sequences of `-` with a single `-`
      anchor_link %<>%
        stringr::str_replace_all(pattern = "-{2,}",
                                 replacement = "-")
    }
    
    # if the same anchor already exists, add an incrementing number starting at 1
    if (anchor_link %in% preceding_anchor_links) {
      
      incrementing_number <- 1L
      
      while (any(stringr::str_detect(string = preceding_anchor_links,
                                     pattern = paste0("^", anchor_link, "-", incrementing_number, "$")))) {
        
        incrementing_number %<>% magrittr::add(1L)
      }
      
      anchor_link %<>% paste0("-", incrementing_number)
    }
    
  } else {
    
    anchor_link <- NA
  }
  
  anchor_link
}

#' Process Markdown document line by line (clean it and build new TOC entries)
#' 
#' @keywords internal
process_md <- function(md_lines,
                       non_code_block_indices,
                       min_tier,
                       max_tier,
                       md_flavor,
                       add_backlinks,
                       backlink_strings,
                       backlink_position,
                       toc_id,
                       old_toc_id,
                       new_toc_id,
                       new_toc_id_position,
                       use_fallback,
                       is_header_title) {
  
  ## initialize variables
  toc_data <- tibble::tibble(tier = integer(),
                             enumeration = integer(),
                             header_text = character(),
                             anchor_link = character())
  anchor_links <- character()
  enumeration <- 1L
  previous_tier <- 0L
  
  for (i in non_code_block_indices) {
    
    # COMMENTED OUT because neither GitHub nor GitLab do cross-check for duplicates in manually set HTML <id> attributes
    #   # add manually set HTML <id> attributes to `anchor_links`
    #   # GitLab quirk: GitLab currently ignores manually set HTML <id> attributes
    # } else if (md_flavor != "gitlab" &
    #            stringr::str_detect(string = md_lines[i],
    #                                pattern = "<[^>]*?id *?= *?['|\"][^'\"]+?['|\"][^<]*?>")) {
    #   # TODO: multiple id tags on the same line? id tag set in a header line?
    #   anchor_links <-
    #     stringr::str_replace_all(string = md_lines[i],
    #                              pattern = "^(?:.*?)(?:<[^>]*?id *?= *?['|\"])([^'\"]+?)(?:['|\"][^<]*?>)(?:.*?)$",
    #                              replacement = "\\1") %>%
    #     # COMMENTED OUT because GitHub/Lab currently don't check for duplicates in manually set HTML <id> attributes
    #     # convert_header_to_anchor(md_flavor = md_flavor,
    #     #                          preceding_anchor_links = anchor_links,
    #                                backlink_position = backlink_position) %>%
    #     c(anchor_links, .)
    
    # skip non-header lines
    if (stringr::str_detect(string = md_lines[i],
                            pattern = "^ {0,3}#{1,6}\\s+\\S")) {
      
      # remove possibly existing backlinks
      md_lines[i] %<>%
        # remove all links to any defined id
        stringr::str_replace_all(pattern = paste0("\\[[^\\]]*?\\]\\(#(",
                                                  toc_id, "|",
                                                  old_toc_id,
                                                  dplyr::if_else(is_header_title,
                                                                 "",
                                                                 paste0("|", new_toc_id)),
                                                  ")-*?\\) ?"),
                                 replacement = "") %>%
        # remove all anchor links where the link text is no longer than 2 chars
        stringr::str_replace_all(pattern = "\\[[^\\]]{0,2}?\\]\\(#[^\\)]*?\\) ?",
                                 replacement = "") %>%
        # remove trailing whitespaces
        stringr::str_trim(side = "right")
      
      # determine backlink string dynamically based on backlink target's position, so that it always points to the TOC
      backlink_string <- backlink_strings[1L]
      
      if (length(backlink_strings) > 1L & i < new_toc_id_position) {
        
        backlink_string <- backlink_strings[2L]
      }
      
      # extract header text
      header_text <-
        md_lines[i] %>%
        # remove leading hashtags
        stringr::str_replace(pattern = "^ *#+",
                             replacement = "") %>%
        # remove leading and trailing whitespaces
        stringr::str_trim(side = "both") %>%
        # replace markdown links by link text
        stringr::str_replace_all(pattern = "\\[([^\\]]*?)\\]\\([^\\)]*?\\)",
                                 replacement = "\\1")
      
      # update list of TOC anchor links
      anchor_links <-
        convert_header_to_anchor(
          header_text = header_text,
          md_flavor = md_flavor,
          preceding_anchor_links = anchor_links,
          backlink_string = ifelse(add_backlinks & stringr::str_detect(string = md_lines[i],
                                                                       pattern = paste0("^ {0,3}#{", min_tier, ",", max_tier, "}\\s+\\S")),
                                   backlink_string,
                                   character()),
          backlink_position = backlink_position
        ) %>%
        c(anchor_links, .)
      
      # add header to TOC if of tier `min_tier` and `max_tier`
      if (stringr::str_detect(string = md_lines[i],
                              pattern = paste0("^ {0,3}#{", min_tier, ",", max_tier, "}\\s+\\S"))) {
        
        # calculate tier of TOC entry
        tier <-
          md_lines[i] %>%
          stringr::str_extract(pattern = "^ {0,3}#+") %>%
          stringr::str_count(pattern = "#") %>%
          magrittr::subtract(min_tier - 1L)
        
        # update enumeration for ordered list TOC
        enumeration <- dplyr::if_else(tier == previous_tier,
                                      enumeration + 1L,
                                      1L)
        
        # update TOC data
        toc_data %<>% dplyr::add_row(tier = tier,
                                     enumeration = enumeration,
                                     header_text = header_text,
                                     anchor_link = dplyr::last(anchor_links))
        
        # add link back to TOC (if header isn't backlink target)
        if (add_backlinks & !(use_fallback & i == new_toc_id_position)) {
          
          # split hashtags from rest of header
          header_split <-
            md_lines[i] %>%
            stringr::str_split(pattern = "(?<=#{1,6} )",
                               n = 2L) %>%
            dplyr::first()
          
          # add backlink depending on `backlink_position`
          if (backlink_position == "after") {
            
            header_split[2L] %<>%
              stringr::str_trim(side = "right") %>%
              paste0(" [", backlink_string, "](#", new_toc_id, ")")
            
          } else {
            
            header_split[2L] %<>%
              paste0("[", backlink_string, "](#", new_toc_id, ") ", .)
          }
          
          # put header pieces back together
          md_lines[i] <- paste0(header_split, collapse = "")
        }
        
        # update previous tier
        previous_tier <- tier
      }
    }
  }
  
  list(md_lines = md_lines,
       toc_data = toc_data)
}



#' Add a table of contents (TOC) to an (R) Markdown document
#' 
#' DESCRIPTION Blabla...
#' 
#' This function tries to adhere to the [CommonMark specification](http://commonmark.org/), i.e. to interpret the Markdown syntax the same way as the
#' [commonmark.js](https://github.com/jgm/commonmark.js) reference implementation under <try.commonmark.org> does.
#' 
#' @param md (R) Markdown document to be processed as a single file path, a single URL or a character vector (one string per line).
#' @param min_tier Minimum tier of headers (`<h1>` – `<h6>`) to include in the TOC. Integer between `1` and `6`. `min_tier = 2` for example means to create TOC
#'   entries for all `<h2>` and below headers.
#' @param max_tier Maximum tier of headers (`<h1>` – `<h6>`) to include in the TOC. Integer between `1` and `6`. `max_tier = 5` for example means to create TOC
#'   entries for all headers down to `<h5>`. `max_tier` must be >= `min_tier`.
#' @param position Position in the Markdown document at which to add the TOC. Possible values include:
#'   - `"top"`: The very beginning of the document, i.e. the first line.
#'   - `"bottom"`: The very end of the document, i.e. the last line.
#'   - `"above"`: Above the lines between the uppermost header of tier <= `min_tier` and the next header above (if any).
#'   - `"below"`: Below the lines between the uppermost header of tier <= `min_tier` and the next header above (if any), i.e. right above the uppermost header
#'     of tier <= `min_tier`.
#'   - `"none"`: Only remove a possibly existing TOC.
#'   - A line number, given as a positive integer.
#' @param md_flavor Markdown flavor. Possible values include:
#'   - `"github"`: 
#'   - `"gitlab"`: 
#' @param add_title Include a TOC title? Logical. Note that no backlinks are
#'   added at all if `add_title = FALSE` and no header line are found above
#'   `position`, regardless of `add_backlinks = TRUE`.
#' @param title Title of the TOC. A character scalar.
#' @param title_tier Tier/formatting of TOC title. Possible values include:
#'   - An integer between `1L` and `6L` representing the `<h1>` – `<h6>` tier.
#'   - `"regular"`: Simple unformatted non-header text.
#'   - `"bold"`: Bold (`<strong>`) non-header text.
#'   - `"italic"`: Italic (`<em>`) non-header text.
#' @param add_backlinks Add a link back to the TOC to each Markdown header. A logical scalar. Note that if `add_backlinks = TRUE` and `add_title = FALSE`, as a
#'   fallback the backlinks point to the next header line above `position` (if any found). This will also be the case if `md_flavor = "gitlab"` and
#'   `title_tier` is set to a non-header value (`"regular"`, `"bold"` or `"italic"`) because GitLab currently ignores manually set HTML `<id>` attributes.
#' @param backlink_strings String(s) to use as link text back to the TOC. A character vector of length 1 or 2. If two strings are provided, the first one will
#'   be used for backlinks below `position`, the second one for backlinks above `position`. Note that at least Unicode 7.0 support is required for the default
#'   symbols `\U1F805` and `\U1F807` to be correctly displayed.
#' @param backlink_position Position of the backlinks. Possible values include:
#'   - `"before"`: Before the actual header text.
#'   - `"after"`: After the actual header text.
#' @param listing_style Format to use for listing the TOC entries. Possible values include:
#'   - `"-"`: Create an unordered list using a hyphen as listing symbol.
#'   - `"*"`: Create an unordered list using an asterisk as listing symbol.
#'   - `"ordered"`: Create an ordered list using `1`, `2`, `3`, ...  as listing symbols.
#'   - `"indented"`: Use non-breaking spaces (`&nbsp;`) to create visual indentation. Useful if the headers are already numbered.
#' @param toc_id HTML `<id>` attribute of the TOC title if `title_tier` is set to a non-header value (`"regular"`, `"bold"` or `"italic"`). A character scalar.
#' @param old_toc_id HTML `<id>` attribute of the old TOC title (in order to have old backlinks with an ID other than `toc_id` removed). A character scalar.
#'
#' @return The processed Markdown document as a character vector (one string per line).
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' "https://raw.githubusercontent.com/ropensci/pdftools/e7248d9956c7e73968628fa3a8ed37f0a8c23b37/README.md" %>%
#'   add_toc(position = 9) %>%
#'   cat(sep = "\n")
#' 
#' add_toc(md = "https://raw.githubusercontent.com/ropensci/pdftools/e7248d9956c7e73968628fa3a8ed37f0a8c23b37/README.md",
#'         listing_style = "ordered") %>%
#'   readr::write_lines(path = "rmarkdown_README_incl_TOC.md")
add_toc <- function(md,
                    min_tier = 2L,
                    max_tier = 6L,
                    position = "above",
                    md_flavor = c("github", "gitlab"),
                    add_title = TRUE,
                    title = "Table of contents",
                    title_tier = min_tier,
                    add_backlinks = add_title,
                    backlink_strings = c("\U1F805", "\U1F807"),
                    backlink_position = c("before", "after"),
                    listing_style = c("-", "*", "ordered", "indented"),
                    toc_id = "toc",
                    old_toc_id = toc_id) {
  
  # --------------------------
  # argument checks begin here
  # ..........................
  
  ## character vector length checks
  vars_to_check <- list(title = title,
                        toc_id = toc_id,
                        old_toc_id = old_toc_id)
  
  for (i in seq_along(vars_to_check)) {
    test_result <- checkmate::check_string(x = vars_to_check[[i]],
                                           min.chars = 1L)
    
    if (!isTRUE(test_result)) {
      rlang::abort(glue::glue("Invalid argument provided: `{names(vars_to_check)[i]}`\n{test_result}"))
    }
  }
  
  ## boolean length checks
  vars_to_check <- list(add_title = add_title,
                        add_backlinks = add_backlinks)
  
  for (i in seq_along(vars_to_check)) {
    test_result <- checkmate::check_flag(vars_to_check[[i]])
    
    if (!isTRUE(test_result)) {
      rlang::abort(glue::glue("Invalid argument provided: `{names(vars_to_check)[i]}`\n{test_result}"))
    }
  }
  
  ## `md`
  if (length(md) > 1L) {
    test_file <- FALSE
    test_url <- FALSE
    test_result <- checkmate::check_character(x = md,
                                              any.missing = FALSE)
    
    if (!isTRUE(test_result)) {
      rlang::abort(glue::glue("Invalid argument provided: `md`\n{test_result}\n`md` must be a character vector or alternatively a readable file path or URL ",
                              "(as a string)."))
    }
  } else {
    test_file <- checkmate::check_file_exists(x = md,
                                              access = "r")
    test_url <- pal::is_http_success(md)
    
    if (!isTRUE(test_file) & !isTRUE(test_url)) {
      rlang::abort(glue::glue("Invalid argument provided: `md`\n{test_file}\n'{md}' is not a valid file path or URL\n",
                              "`md` must be a file path or a URL pointing to the Markdown document, or alternatively the Markdown document itself as a ",
                              "character vector."))
    }
  }
  
  ## `position`
  choices <- c("top", "bottom", "above", "below", "none")
  
  test_char <- checkmate::check_choice(x = position,
                                       choices = choices)
  
  test_num <- checkmate::check_count(x = position,
                                     positive = TRUE)
  
  if (!isTRUE(test_char) & !isTRUE(test_num)) {
    rlang::abort(glue::glue("\nInvalid argument provided: `position`\nMust be either an integer >= 1 or an element of the set {",
                        paste0("'", choices, "'", collapse = ", "), "}, but is '{position}'"
    ))
  }
  
  ## `title_tier`
  choices <- c("regular", "bold", "italic")
  test_char <- checkmate::check_choice(x = title_tier,
                                       choices = choices)
  test_num <- checkmate::check_int(x = title_tier,
                                   lower = 1L,
                                   upper = 6L)
  
  if (!isTRUE(test_char) & !isTRUE(test_num)) {
    rlang::abort(glue::glue("\nInvalid argument provided: `title_tier`\nMust be either an integer between 1 and 6 or an element of the set {",
                        paste0("'", choices, "'", collapse = ", "), "}, but is '{title_tier}'"))
  }
  
  ## `min_tier`
  test_result <- checkmate::check_int(x = min_tier,
                                      lower = 1L,
                                      upper = 6L)
  
  if (!isTRUE(test_result)) {
    rlang::abort(glue::glue("\nInvalid argument provided: `min_tier`\n{test_result}"))
  }
  
  ## `max_tier`
  test_result <- checkmate::check_int(x = max_tier,
                                      lower = min_tier,
                                      upper = 6L)
  
  if (!isTRUE(test_result)) {
    rlang::abort(glue::glue("\nInvalid argument provided: `max_tier`\n{test_result}"))
  }
  
  ## `md_flavor`
  md_flavor <- rlang::arg_match(md_flavor)
  
  ## `backlink_strings`
  test_result <- checkmate::check_character(x = backlink_strings,
                                            min.chars = 1L,
                                            any.missing = FALSE,
                                            min.len = 1L,
                                            max.len = 2L)
  
  if (!isTRUE(test_result)) {
    rlang::abort(glue::glue("Invalid argument provided: `backlink_strings`\n{test_result}"))
  }
  
  ## `backlink_position`
  backlink_position <- rlang::arg_match(backlink_position)
  
  ## `listing_style`
  listing_style <- rlang::arg_match(listing_style)
  
  # ........................
  # argument checks end here
  # ------------------------
  
  # read in `md` if necessary
  if (isTRUE(test_file) | isTRUE(test_url)) {
    
    md_lines <- readr::read_lines(file = md)
    
  } else {
    
    md_lines <- md
  }
  
  # find code blocks
  non_code_block_indices <- get_non_code_block_indices(md_lines = md_lines)
  
  # handle existing TOC (check integrity, remove it if present and adjust position)
  result <- handle_existing_toc(md_lines = md_lines,
                                non_code_block_indices = non_code_block_indices,
                                position = position,
                                filename = ifelse(isTRUE(test_file),
                                                  basename(md),
                                                  "Input"))
  
  md_lines <- result[["md_lines"]]
  position_offset <- result[["position_offset"]]
  non_code_block_indices <- result[["non_code_block_indices"]]
  
  # evaluate position (get actual line number)
  position %<>% evaluate_position(position_offset = position_offset,
                                  md_lines = md_lines,
                                  min_tier = min_tier,
                                  filename = basename(md))
  
  # determine fallback HTML <id> attribute position for backlinks (ID of next header line above the TOC if existing)
  fallback_id_position <-
    dplyr::if_else(position > 1L,
                   stringr::str_which(string = md_lines[1L:(min(length(md_lines), max(position - 1L, 1L)))],
                                      pattern = "^ {0,3}#{1,6}\\s+\\S") %>%
                     dplyr::last() %>%
                     # if no header lines above TOC found, set to -1
                     dplyr::if_else(is.na(.), -1L, .),
                   # if `position` is 1 (or "none") there can't be any header lines above TOC
                   1L)
  
  # determine if TOC title is a header or not
  is_header_title <- is.numeric(title_tier)
  
  # determine if we actually fall back
  use_fallback <-
    dplyr::case_when(
      !add_title & fallback_id_position > 0L ~ TRUE,
      
      # GitLab quirk: GitLab currently ignores manually set HTML <id> attributes (effective July 2017)
      md_flavor == "gitlab" & !is_header_title & fallback_id_position > 0L ~ TRUE,
      
      TRUE ~ FALSE
    )
  
  # set position of new TOC ID
  new_toc_id_position <- dplyr::if_else(use_fallback,
                                        fallback_id_position,
                                        as.integer(position))
  
  # generate actual TOC ID if `position != "none"` (ensure it's unique)
  if (new_toc_id_position > 0L) {
    
    ## get all header texts preceding `new_toc_id_position` (to avoid duplicates)
    preceding_anchor_links <-
      # extract all header lines until `new_toc_id_position`
      stringr::str_subset(string = md_lines[1L : dplyr::case_when(use_fallback ~ new_toc_id_position,
                                                                  TRUE ~ as.integer(new_toc_id_position - 1L))],
                          pattern = "^ {0,3}#{1,6}\\s+\\S") %>%
      # remove leading hashtags
      stringr::str_replace(pattern = "^ *#+",
                           replacement = "") %>%
      # remove all links to any defined id
      stringr::str_replace_all(pattern = paste0("\\[[^\\]]*?\\]\\(#(", toc_id, "|", old_toc_id, ")-*?\\)"),
                               replacement = "") %>%
      # remove all anchor links where the link text is no longer than 2 chars
      stringr::str_replace_all(pattern = "\\[[^\\]]{0,2}?\\]\\(#[^\\)]*?\\)",
                               replacement = "") %>%
      # remove leading and trailing whitespaces
      stringr::str_trim(side = "both")
    
    ## convert header texts to anchor links
    if (length(preceding_anchor_links) > 0L) {
      
      for (i in seq_along(preceding_anchor_links)) {
        
        preceding_anchor_links[i] %<>%
          convert_header_to_anchor(md_flavor = md_flavor,
                                   preceding_anchor_links = preceding_anchor_links[(1L:i) - 1L],
                                   backlink_position = backlink_position)
      }
    }
  } else {
    
    preceding_anchor_links <- character()
  }
  
  ## set actual TOC ID
  new_toc_id <-
    dplyr::case_when(
      # if `position == "none`, use `toc_id` to allow removal of old backlinks
      new_toc_id_position == -1L ~
        toc_id,
      
      use_fallback ~
        dplyr::last(preceding_anchor_links),
      
      is_header_title ~
        convert_header_to_anchor(header_text = title,
                                 md_flavor = md_flavor,
                                 preceding_anchor_links = preceding_anchor_links,
                                 backlink_position = backlink_position),
      
      TRUE ~
        convert_header_to_anchor(header_text = toc_id,
                                 md_flavor = md_flavor,
                                 preceding_anchor_links = preceding_anchor_links,
                                 backlink_position = backlink_position)
    )
  
  # avoid addition of backlinks if impossible or `position = "none"`
  # GitLab quirk: note that GitLab currently ignores the HTML <id> attribute added to a non-header TOC title
  if (new_toc_id_position == -1L) {
    
    add_backlinks <- FALSE
  }
  
  # clean `md` from existing backlinks, add new backlinks and build new TOC)
  result <- process_md(md_lines = md_lines,
                       non_code_block_indices = non_code_block_indices,
                       min_tier = min_tier,
                       max_tier = max_tier,
                       md_flavor = md_flavor,
                       add_backlinks = add_backlinks,
                       backlink_strings = backlink_strings,
                       backlink_position = backlink_position,
                       toc_id = toc_id,
                       old_toc_id = old_toc_id,
                       new_toc_id = new_toc_id,
                       new_toc_id_position = new_toc_id_position,
                       use_fallback = use_fallback,
                       is_header_title = is_header_title)
  
  md_lines <- result[["md_lines"]]
  toc_data <- result[["toc_data"]]
  
  # proceed if at least 1 header entry was found for TOC
  if (nrow(toc_data) > 0L) {
    
    # assemble final TOC
    toc <- character()
    
    ## determine if TOC entries have to be moved up in listing hierarchy
    ## (this is the case when only headers < `min_tier` are contained in md document)
    toc_tier_offset <- min(toc_data$tier) - 1L
    
    ## determine if TOC as a "proper" list is possible ...
    ## (not the case when 1st TOC entry is not of minimum tier)
    is_toc_list_possible <- toc_data$tier[1L] == min(toc_data$tier)
    
    ## ... and use a WORKAROUND if necessary
    if (!is_toc_list_possible & listing_style != "indented") {
      
      warning("Uncommon header hierarchy detected in Markdown document which ",
              "cannot be represented by a conventional (un)ordered Markdown list (first header to be included in TOC is of ",
              "lower tier than some subsequent ones). Therefore `listing_style` was automatically set to `\"none\"`.",
              call. = FALSE)
      
      listing_style <- "indented"
    }
    
    ## assemble TOC entries
    for (i in seq_len(nrow(toc_data))) {
      
      toc %<>% c(dplyr::case_when(listing_style == "ordered" ~
                                    stringr::str_dup(string = "    ",
                                                     times = toc_data$tier[i] - 1L - toc_tier_offset) %>%
                                    paste0(toc_data$enumeration[i], ". [", toc_data$header_text[i], "]", "(#", toc_data$anchor_link[i], ")"),
                                  
                                  listing_style == "indented" ~
                                    stringr::str_dup(string = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",
                                                     times = toc_data$tier[i] - 1L - toc_tier_offset) %>%
                                    paste0("[", toc_data$header_text[i], "]", "(#", toc_data$anchor_link[i], ")  "),
                                  
                                  TRUE ~
                                    stringr::str_dup(string = "    ",
                                                     times = toc_data$tier[i] - 1L - toc_tier_offset) %>%
                                    paste0(listing_style, " [", toc_data$header_text[i], "]", "(#", toc_data$anchor_link[i], ")")))
    }
    
    ## define TOC begin and end comments for identification
    toc_begin_comment <- "<!-- TOC BEGIN -- leave this comment untouched to allow auto update -->"
    toc_end_comment <- "<!-- TOC END -- leave this comment untouched to allow auto update -->"
    
    ## assemble complete TOC
    toc <-
      dplyr::case_when(add_title & title_tier == "regular" ~
                         list(c(toc_begin_comment,
                                "",
                                paste0("<p id='", toc_id, "'>", title, "</p>"),
                                "",
                                toc,
                                "",
                                toc_end_comment
                         )),
                       
                       add_title & title_tier == "bold" ~
                         list(c(toc_begin_comment,
                                "",
                                paste0("<strong id='", toc_id, "'>", title, "</strong>"),
                                "",
                                toc,
                                "",
                                toc_end_comment
                         )),
                       
                       add_title & title_tier == "italic" ~
                         list(c(toc_begin_comment,
                                "",
                                paste0("<em id='", toc_id, "'>", title, "</em>"),
                                "",
                                toc,
                                "",
                                toc_end_comment
                         )),
                       
                       add_title ~
                         list(c(toc_begin_comment,
                                "",
                                paste0(stringr::str_dup(string = "#",
                                                        times = ifelse(is_header_title,
                                                                       title_tier,
                                                                       0L)),
                                       " ",
                                       title),
                                "",
                                toc,
                                "",
                                toc_end_comment
                         )),
                       
                       TRUE ~
                         list(c(toc_begin_comment,
                                "",
                                toc,
                                "",
                                toc_end_comment
                         ))) %>%
      unlist()
    
    ## if line above/below is not empty, add additional empty line above/below TOC
    if (position > 1L & !stringr::str_detect(string = md_lines[max(position - 1L, 1L)],
                                             pattern = "^\\s*$")) {
      toc %<>% c("", .)
    }
    
    if (position < length(md_lines) & !stringr::str_detect(string = md_lines[max(position, 1L)],
                                                           pattern = "^\\s*$")) {
      toc %<>% c("")
    }
    
    # insert new TOC
    md_lines_new <-
      dplyr::case_when(position == -1L ~
                         list(md_lines),
                       
                       position == 1L ~
                         list(c(toc,
                                md_lines)),
                       
                       position == length(md_lines) + 1L ~
                         list(c(md_lines,
                                toc)),
                       
                       TRUE ~
                         list(c(md_lines[1L : max(position - 1L, 1L)],
                                toc,
                                md_lines[max(position, 1L) : length(md_lines)]))) %>%
      unlist()
    
  } else {
    message("\nNo header entries of `min_tier` (<h", min_tier, ">) or below found in '", basename(md), "'! Nothing done.\n")
    md_lines_new <- md_lines
  }
  
  md_lines_new
}

#' Remove an auto-generated table of contents (TOC) from an (R) Markdown document
#' 
#' This is a simple convenience wrapper for `add_toc(..., position = "none")`.
#' 
#' @inheritParams add_toc
#' 
#' @inherit add_toc return
#' @seealso [add_toc()]
#' @export
#' 
#' @examples
#' library(magrittr)
#' 
#' remove_toc(md = paste0("https://raw.githubusercontent.com/thlorenz/doctoc/",
#'                        "1d386261972d35c6bcd187d0a00e666f9d893d8d/README.md")) %>%
#'   cat(sep = "\n")
remove_toc <- function(md,
                       old_toc_id = toc_id) {
  add_toc(md = md,
          position = "none",
          old_toc_id = old_toc_id)
}
